## 图
### 邻接矩阵
二维数组，行和列都是顶点的个数。第i行j列的值为顶点到顶点j的边的权。

### 邻接表
使用五个一维数组存储边的属性和点边关系。
* u/v/w分别存储起点，终点，权重。下标为边的编号。  
* first存储顶点出去的第一条边。下标为顶点。  
* next存储同一起点出来的边。下标为边。可以想象first数组指向next数组的位置为第一条边，而第一条边指向next数组中的位置为第二条边，如此类推。  

### 深度优先搜索
首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点，当没有未访问过的顶点时，则回到上一顶点，继续试探访问别的顶点，直到所有顶点都被访问过。
```C
[使用邻接矩阵]
function(当前点状态，[前一点状态])
    [结束条件]
    [边界条件]
    遍历下一种可能
        如果符合条件(book状态)
            更新状态
            [加到列表，计数]
            递归调用
            [回溯]
```

### 广度优先搜索
```C
[使用邻接矩阵]
第一个元素入队
While(队列不为空)
    [结束条件]
    遍历从head元素能到达的下一个元素
        如果符合条件(book状态)
            更新状态
            加入队列尾部
    head指针后移一个元素
```

### floyd
求任意点之间的最短距离。  
```C
使用邻接矩阵
遍历所有顶点(中转点)
    遍历所有顶点(起点)
        遍历所有顶点(终点)
            if(e[起点][终点] > e[起点][中转点] + e[中转点][终点]) //注意检查加法溢出
                e[起点][终点] = e[起点][中转点] + e[中转点][终点] //更新最短距离
```

### Dijkstra
求指定边到其余各边的最短距离。不支持负权边。  
使用一个dis数组，下标为顶点，值为最短路程的"估计值"。先找一个离指定点最近的点，该点（假设为u点）的dis值成为确定值，然后看通过u点可否缩短指定点到其余点的距离，如果可以，更新dis，称为松弛。从剩下的点中取一个离指定点最近的，进行松弛，如此类推。直到所有点成为确定点。  
```C
初始化dis数组值为无限，指定点值为0
标记指定点为确定（book）
循环顶点数减一次
    找到未标记为确定且距指定点最短的顶点
    标记该顶点为确定
    更新其余可以通过该顶点缩短距离的顶点的dis
```

### Bellman-ford
求指定边到其余各边的最短距离。支持负权边。对所有边进行顶点数减一次松弛。
```C
使用邻接表
循环顶点数减一次
    循环边数
        更新其余可以通过该顶点缩短距离的顶点的dis
```
可以使用队列进行优化，类似BFS。只对距离发生变化的点进行松弛。  

## 树
树其实是不包含回路的连通无向图。  
特点:  
* 一棵树中任意两个结点有且仅有一条路径相通   
* n个结点有n-1条边   
*加一条边将产生回路   

### 二叉树
二叉树的每个结点最有两个子结点。   

### 满二叉树
每个内部结点都有两个子结点。   

### 完全二叉树
每个内部结点都有两个子结点，只允许最后一层从右往左连续缺失叶结点。  
可以用数组实现，从头到脚，从左到右。左子结点为2*k，右子结点为2*k+1，高度为log N。
最大堆为父结点都比子结点大的完全二叉树。  
优先队列支持插入元素和查找最大最小值。  

#啊哈算法
《啊哈，算法》一书的代码，以书为基础，或许添加一些可以改进的地方。

## 代码列表
| 名字 | 描述 | 页数 |
|------|-----|------|
| bucket.c | 桶排序 | 4 |
| bubble.c | 冒泡排序 | 9 |
| bubble_student.c | 冒泡排序(结构体) | 10 |
| quick.c | 快速排序 | 18 |
| buy_book1.c | 去重及排序ISBN号（桶排序） | 22 |
| queue.c | 使用队列实现猜QQ号码 | 29 |
| stack.c | 使用栈判断字符串是否回文 | 34 |
| cat_fish.c | 小猫钓鱼纸牌游戏 | 40 |
| link_list.c | 实现链表 | 50 |
| link_list2.c | 实现链表，并在中间插入一个数 | 52 |
| link_list3.c | 使用数组实现链表，并在中间插入一个数 | 55 |
| boom_man.c | 使用枚举解决炸弹人游戏只最佳的炸弹放置点 | 64 |
| matchstick.c | 使用火柴棍摆出等式a+b=c，给定火柴棍的个数，能摆出多少种等式 | 68 |
| dfs.c | 数的全排列，使用深度搜索实现 | 78 |
| labyrinth.c | 解救小哈，最短路径到达迷宫的某点 | 85 |
| bfs.c | 解救小哈，寻找到迷宫中某点的步数，使用广度优先 | 92 |
| boom_man_bfs.c | 使用广度优先搜索解决炸弹人问题 | 100 |
| boom_man_dfs.c | 使用深度优先搜索解决炸弹人问题 | 103 |
| island_area_bfs.c | 使用广度优先搜索解决求岛面积问题 | 107 |
| island_area_dfs.c | 使用深度优先搜索解决求岛面积问题 | 110 |
| island_color_dfs.c | 使用深度优先搜索着色着陆点的岛屿 | 112 |
| island_color_dfs2.c | 使用深度优先搜索着色所有岛屿(floodfill) | 115 |
| plumber_dfs.c | 使用深度优先搜索解决水管工问题 | 124 |
| traverse_graph_dfs.c | 使用深度优先搜索遍历图 | 131 |
| traverse_graph_bfs.c | 使用广度优先搜索遍历图 | 134 |
| shortest_path_dfs.c | 使用深度优先搜索查找两个城市之间的最短路径 | 139 |
| airline_bfs.c | 使用广度优先求解最少转机次数 | 144 |
| floyd.c | 使用floyd算法求任意点间最短距离 | 152 |
| dijkstra.c | 使用Dijkstra算法求一个顶点到其他任一顶点的最短距离 | 158 |
| bellman_ford.c | 使用Bellman-Ford算法求最短路程 | 163 |
| bellman_ford2.c | 使用Bellman-Ford算法求最短路程，通过检测无法松驰以提前跳出循环 | 170 |
| bellman_ford3.c | 使用Bellman-Ford算法求最短路程，使用队列优化 | 174 |
| heap_sort.c | 堆排序，通过建立堆，删除元素后调整堆 | 195 |
| heap_sort2.c | 堆排序，通过建立最大堆，最大元素必定在第一位 | 198 |
| bcj.c | 并查集，判断有多少个团伙 | 208 |
| kruskal.c | 最小生成树 | 217 |
| prim.c | 最小生成树，使用prim算法 | 221 |
| prim2.c | 最小生成树，使用prim算法，使用邻接表和堆优化 | 224 |
| gedian.c | 求图的割点 | 232 |
